# Haskell/Yesod from scratch with Nix on Mac OS X

The easiest way to get started with Haskell/Yesod on Mac, is to install Haskell Platform - <a href="https://www.haskell.org/platform/mac.html">https://www.haskell.org/platform/mac.html</a>.  And that's where most Haskell beginners start with if they are Mac users.

After a while as one becomes more acquainted with Haskell, it becomes obvious that being tied to a older, fixed binary version (Haskell Platform's toolchain and ghc) is very limiting and prevents us from contributing effectively back to the Haskell/Hackage ecosystem.  This is where Nix excels - it allows us to switch between different Haskell toolchain/ghc, create hermetic builds and leverage on both community-contributed binaries as well as community-contributed source efficiently.  Cabal sandbox does that to a certain extent but depending on source-only compilation shortens our life. :-)  After all, we only have that much time and we don't want to waste our precious time compiling sources *ALL THE TIME*, or do we?

If that's where you are and you would like to start leveraging on the benefits of Nix, start by uninstalling Haskell Platform.  A small shell script here would help you uninstall Haskell Platform cleanly - <a href="https://github.com/hskoans/HaskellUtilities/blob/master/uninstall-haskell-platform.sh">https://github.com/hskoans/HaskellUtilities/blob/master/uninstall-haskell-platform.sh</a>.

It is possible to use both the ghc installed via Haskell Platform and the ghc installed via Nix but that requires a lot of work to make sure you get your PATH right; or all hell will break loose.  I have a simple `use_haskell` shell function in my dotfiles that facilitates switching between Haskell Platform and Nix-installed ghc/cabal tool chain but I do not recommend that you use it.

It's far too easy to get it wrong juggling the PATHs between Haskell Platform binaries and Nix-env installed binaries in your user space; and causing all sorts of unexpected build errors as a result.

My recommendation is that you switch to using Nix completely and revel in the power of hermetic builds.

## Using nixpkgs unstable

```
cd ~
git clone git@github.com/NixOS/nixpkgs
cd ~/.nix-defexpr
rm -rf channels
ln -s ~/nixpkgs nixpkgs
export NIX_PATH=nixpkgs=$HOME/nixpkgs:$NIX_PATH  # place this in .bash_profile or .zprofile to persist it
```

## Using binaries instead of compiling every damn thing

```
sudo mkdir /etc/nix
sudo vim /etc/nix/nix.conf
```

In `nix.conf`, add in:

```
binary-caches = http://zalora-public-nix-cache.s3-website-ap-southeast-1.amazonaws.com/ http://cache.nixos.org/ http://hydra.nixos.org/
```

This saves us a ton of time thanks to zalora's Mac OS X 10.10's binaries.  Note that it does not work with Mac OS X 10.9.

## Base requirements

Here are some basic utilities we need to get started:

```
nix-env -iA nixpkgs.haskellPackages.ghc
nix-env -iA nixpkgs.haskellPackages.cabal-install
nix-env -iA nixpkgs.haskellPackages.cabal2nix
nix-env -iA nixpkgs.haskellPackages.yesod-bin
```

Now, we can scaffold our Yesod project

```
cd ~/work  # This is just a directory where I keep most of my projects
mkdir Yesod1
cd Yesod1
yesod init --bare
```

This is needed if we are running cabal for the first time, otherwise, it's optional.

```
cabal update
```

We will also need to specify this for Mac OS X

```
export NIX_CFLAGS_COMPILE="-idirafter /usr/include"
export NIX_CFLAGS_LINK="-L/usr/lib"
```

as Nix does not know the location of C libraries like Math.h


Let's install and get cracking.

```
# Set up cabal sandbox
cabal sandbox init

# happy and alex are required
cabal install happy alex

# Now, for the actual dependencies required by Yesod (as specified in our Yesod1.cabal file which was generated by our `yesod init --bare` command)
cabal install -j --enable-tests --max-backjumps=-1 --reorder-goals

# Start our yesod app
yesod devel
```

## Bumped into some errors?

```
readlink: illegal option -- f
usage: readlink [-n] [file ...]
```

This is because on linux, the `readline` utility accepts an option `-f`.  But Mac OS X/BSD's readline does not have this behavior.

To solve this problem, we can install `greadlink` which is available in `coreutils` via brew or macports and then make the `readlink` program symlink to `greadlink`.

I use Macports and my `/opt/local/bin` path takes precedence over `/usr/bin`.

So, after installing `coreutils`, I simply run:

```
sudo ln -s /opt/local/bin/greadlink /opt/local/bin/readlink
source ~/.zprofile   # or .bash_profile if you use bash, or just restart your shell
```

Now, `yesod devel` will not result in the `readlink: illegal option --f` errors

A better solution is to use the readlinke in `coreutils` that comes with Nix. :-)

```
$ nix-env -qaP coreutils
nixpkgs.coreutils  coreutils-8.23
$ nix-env -iA nixpkgs.coreutils
```

Since `$HOME/.nix-profile/bin` PATH takes precendence over `/opt/local/bin` (Macports) and takes precedence over the built-in Mac OS X PATHs `/user/local/bin`,`/usr/bin` and `/bin`, we should be good to go.

## Let's have some fun with Haskell/Yesod

### cabal2nix for shell.nix

`cabal2nix`'s `--shell` flag when-specified creates a nix expression file that is intended to be loaded as an entry point when we run the `nix-shell` command.

```
cd ~/work/Yesod1   # That's where our yesod-scaffolded source code is
cabal2nix --shell . > shell.nix
```

We can jump into our Nix shell environment to work on our Yesod1 project by simply running `nix-shell`.

### cabal2nix for default.nix

The `default.nix` file, on-the-other-hand, makes our `Yesod1` project a package that can be called in Nix.  It is not loaded by `shell.nix` in this case.

```
cabal2nix . > default.nix
```

We can now edit `~/.nixpkgs/config.nix`:

```
{
  packageOverrides = super: let self = super.pkgs; in
  {
    yesod1 = self.haskellPackages.callPackage ../work/Yesod1 {};
  };
}
```

When we do this, we make it possible to run `nix-env -iA yesod1`.

## What if we want to use a different compiler?

First, we understand that haskell packages are organized on a per-compiler basis.

```
$ nix-env -qaP -A nixpkgs.haskell.packages.ghc7101
$ nix-env -qaP -A nixpkgs.haskell.packages.ghc784
$ nix-env -qaP -A nixpkgs.haskell.packages.ghc763
```

How did we know what are all available compiler versions?

```
$ nix-env -qaP -A nixpkgs.haskell.compiler
nixpkgs.haskell.compiler.ghc704Binary  ghc-7.0.4-binary
nixpkgs.haskell.compiler.ghc7101       ghc-7.10.1
nixpkgs.haskell.compiler.ghcHEAD       ghc-7.11.20150607
nixpkgs.haskell.compiler.ghc742        ghc-7.4.2
nixpkgs.haskell.compiler.ghc742Binary  ghc-7.4.2-binary
nixpkgs.haskell.compiler.ghc763        ghc-7.6.3
nixpkgs.haskell.compiler.ghc784        ghc-7.8.4
nixpkgs.haskell.compiler.ghcjs         ghcjs-0.1.0
```

At this time of writing, `nixpkgs.haskellPackages.ghc` is pointing to `nixpkgs.haskell.compiler.ghc7101`, which is why our `cabal2nix` utility picked that up above and created a `shell.nix` that uses `ghc7101`.  We can easily get our `Yesod1` project to switch to using another ghc version by changing that and running `nix-shell` again.

## Switching between different compilers at user-level instead of project-level

What if we want to switch between different compilers at our user nix-env level?

We can do that by imperatively running `nix-env -iA nixpkgs.haskell.packages.ghc784`, or since Nix is a declarative thing, we can stop having to remember and type all these commands and place these declarations in our `$HOME/.nixpkgs/config.nix` file.

For instance, create our `$HOME/.nixpkgs/config.nix` file and write this in it:

```
{
  allowUnfree = true;
  packageOverrides = super: let self = super.pkgs; in
  {
    hs7101 =
      self.haskell.packages.ghc7101.ghcWithPackages
        (haskellPackages: with haskellPackages; [
          cabal-install cabal2nix hdevtools
          /*ghc-mod is broken for 7101 at this moment*/
        ]);
    hs784 =
      self.haskell.packages.ghc784.ghcWithPackages
        (haskellPackages: with haskellPackages; [
          cabal-install cabal2nix hdevtools ghc-mod
        ]);
  };
}
```

With these, we can toggle between the set of tools/compiler we want to use by running either:

```
nix-env -iA nixpkgs.hs7101
```

or

```
nix-env -iA nixpkgs.hs784
```

Easy peasy.
